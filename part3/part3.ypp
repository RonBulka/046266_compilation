%{
	#include "part3_helpers.hpp"

    using namespace std;
    
	extern char *yytext;
	extern int yylineno;
	extern int yylex();
	
	void yyerror(char const * message);
	extern void yylex_destroy();
	void printSemanticError(string error);
	void printOperationalError(string error);
%}

// declare tokens we get from lexer and their types and their associativity
%token INT FLOAT VOID WRITE_ READ_ OPTIONAL WHILE DO IF RETURN_ COLON SEMICOLON ID INTEGERNUM REALNUM STR 

%right THEN
%right ELSE

%left COMMA
%right ASSIGN
%left OR
%left AND
%left RELOP
%left ADDOP
%left MULOP
%right LPAREN RPAREN NOT
%left LBRACE RBRACE

%%
// define grammar rules
// root rule
PROGRAM : FDEFS { 
		// after parsing the whole program, we need to fill in calls to functions we have implemented
		// fill in the calls to functions
		cerr << "Program parsed successfully" << endl;
		for (map<string, Function>::iterator it = functionTable.begin(); it != functionTable.end(); it++){
			int impAddress = it->second.address;
			buffer->backpatch(it->second.callingAddresses, impAddress);
		}
	}
;

FDEFS :   FDEFS FUNC_DEF_API M BLK {
		// function entry in function table is already done in FUNC_DEF_API
		// check if the function is already implemented
		cerr << "Function '" << $2.str << "' implemented at " << $3.quad << endl;
		if (functionTable[$2.str].implemented){
			printSemanticError("Function '" + $2.str + "' already implemented");
		}
		else { // if the function is not implemented, 
			// set the function as implemented
			functionTable[$2.str].implemented = true;
			// set the function address
			functionTable[$2.str].address = $3.quad;
		}
		// catch void return
		buffer->emit("RETRN");
		// clear symbol table
		symbolTable.clear();
		$2.paramTypes.clear();
		// clear current scope registers
		currentScopeRegsNumInt = 3;
		currentScopeRegsNumFloat = 3;
		// clear current scope offset
		currentScopeOffset = 0;
	}
	| FDEFS FUNC_DEC_API {
		// $2 is a function declaration, its already inserted in the function table by FUNC_DEC_API
		// check if the function is not implemented
		cerr << "Function '" << $2.str << "' declared" << endl;
		if (!functionTable[$2.str].implemented){
			functionTable[$2.str].address = -1;
		}
		// clear symbol table
		symbolTable.clear();
	}
	| /* empty */ { } %empty
;

// function declaration rules, create new function instance and add it to function table
FUNC_DEC_API :   TYPE ID LPAREN RPAREN SEMICOLON {
		cerr << "Function '" << $2.str << "' declared with return type " << $1.type << endl;
		if ($2.str == "main" && $1.type != void_t){
			printSemanticError("Main function must be void");
		}
		if (functionTable.find($2.str) != functionTable.end()) {
			// found in function table
			// check if return type matches
			if (functionTable[$2.str].returnType != $1.type){
				printSemanticError("Function '" + $2.str + "' already declared with different return type");
			}
			// check if parameters match
			else if (functionTable[$2.str].paramTypes.size() != 0){
				printSemanticError("Function '" + $2.str + "' already declared with different parameters");
			}
		}
		else {
			// not found in function table
			// insert function to function table
			Function newFunction;
			newFunction.returnType = $1.type;
			newFunction.implemented = false;
			newFunction.optionalParamsStart = 0;
			newFunction.optionalParamsNum = 0;
			newFunction.paramTypes.clear();
			newFunction.optionalParamsTypes.clear();
			newFunction.optionalParamsValues.clear();
			functionTable[$2.str] = newFunction;
		}
		$$.str = $2.str;
		$$.type = $1.type;
 	}
	| TYPE ID LPAREN FUNC_ARGLIST RPAREN SEMICOLON { 
		cerr << "Function '" << $2.str << "' declared with return type " << $1.type << " and parameters" << endl;
		if ($2.str == "main"){
			printSemanticError("Main function cant have parameters");
		}
		if (functionTable.find($2.str) != functionTable.end()) {
			// found in function table
			// check if return type matches
			if (functionTable[$2.str].returnType != $1.type){
				printSemanticError("Function '" + $2.str + "' already declared with different return type");
			}
			// check if parameters match
			else if (functionTable[$2.str].paramTypes != $4.paramTypes){
				printSemanticError("Function '" + $2.str + "' already declared with different parameters");
			}
			else if (functionTable[$2.str].optionalParamsNum != 0){
				printSemanticError("Function '" + $2.str + "' already declared with optional parameters");
			}
		}
		else {
			// not found in function table
			int offset = -8;
			vector<Type> paramTypesTmp;
			for (int i=0 ; i < currentParamInsertionOrder.size(); i++){
				string param = currentParamInsertionOrder[i];
				Type paramType = symbolTable[param].type[currentBlockDepth];
				paramTypesTmp.push_back(paramType);
				offset -= 4;
				symbolTable[param].offset[currentBlockDepth] = offset;
			}
			// insert function to function table
			Function newFunction;
			newFunction.returnType = $1.type;
			newFunction.implemented = false;
			newFunction.optionalParamsStart = 0;
			newFunction.optionalParamsNum = 0;
			newFunction.paramTypes = paramTypesTmp;
			newFunction.optionalParamsTypes.clear();
			newFunction.optionalParamsValues.clear();
			functionTable[$2.str] = newFunction;

			currentParamInsertionOrder.clear();
		}
		$$.str = $2.str;
		$$.type = $1.type;
	}
	| TYPE ID LPAREN FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { 

	}
	| TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { 
		
	}
;

FUNC_DEC_ARGLIST_OPT : FUNC_DEC_ARGLIST_OPT COMMA DCL_OPT { 

	}
	| DCL_OPT { 

	}
;

DCL_OPT : ID COLON OPTIONAL TYPE { 

	}
	| ID COMMA DCL_OPT{ 

	}
;

// function definition rules
FUNC_DEF_API : TYPE ID LPAREN RPAREN {
		cerr << "Function '" << $2.str << "' about to be implemented with return type " << $1.type << endl;
		if ($2.str == "main" && $1.type != void_t){
			printSemanticError("Main function must be void");
		}
		if (functionTable.find($2.str) != functionTable.end()) {
			// found in function table
			// if not implemented, but declared check if the return type and parameters match
			if (!functionTable[$2.str].implemented){
				// check if return type matches
				if (functionTable[$2.str].returnType != $1.type){
					printSemanticError("Function '" + $2.str + "' already declared with different return type");
				}
				// check if parameters match
				else if (functionTable[$2.str].paramTypes.size() != 0){
					printSemanticError("Function '" + $2.str + "' already declared with different parameters");
				}
			}
			else {
				printSemanticError("Function '" + $2.str + "' already implemented");
			}
		}
		else {
			// not found in function table
			// insert function to function table
			Function newFunction;
			newFunction.returnType = $1.type;
			newFunction.implemented = false;
			newFunction.optionalParamsStart = 0;
			newFunction.optionalParamsNum =0;
			newFunction.paramTypes.clear();
			newFunction.optionalParamsTypes.clear();
			newFunction.optionalParamsValues.clear();
			functionTable[$2.str] = newFunction;
		}
		// set current function return type
		currentReturnType = $1.type;
		// set current function name
		$$.str = $2.str;
		$$.type = $1.type;
		cerr << "finished FUNC_DEF_API" << endl;
	}
	| TYPE ID LPAREN FUNC_ARGLIST RPAREN {
		cerr << "Function '" << $2.str << "' about to be implemented with return type " << $1.type << " and parameters" << endl;
		if ($2.str == "main"){
			printSemanticError("Main function cant have parameters");
		}
		if (functionTable.find($2.str) != functionTable.end()) {
			// found in function table
			// if not implemented, but declared check if the return type and parameters match
			if (!functionTable[$2.str].implemented){
				// check if return type matches
				if (functionTable[$2.str].returnType != $1.type){
					printSemanticError("Function '" + $2.str + "' already declared with different return type");
				}
				// check if parameters match
				else if (functionTable[$2.str].paramTypes != $4.paramTypes){
					printSemanticError("Function '" + $2.str + "' already declared with different parameters");
				}
				else if (functionTable[$2.str].optionalParamsNum != 0){
					printSemanticError("Function '" + $2.str + "' already declared with optional parameters");
				}
			}
			else {
				printSemanticError("Function '" + $2.str + "' already implemented");
			}
		}
		else {
			// set offset and type of each parameter
			int offset = -8;
			vector<Type> paramTypesTmp;
			for (int i=0 ; i < currentParamInsertionOrder.size(); i++){
				string param = currentParamInsertionOrder[i];
				Type paramType = symbolTable[param].type[currentBlockDepth];
				paramTypesTmp.push_back(paramType);
				offset -= 4;
				symbolTable[param].offset[currentBlockDepth] = offset;
			}
			// insert function to function table
			Function newFunction;
			newFunction.returnType = $1.type;
			newFunction.implemented = false;
			newFunction.optionalParamsStart = 0;
			newFunction.optionalParamsNum = 0;
			newFunction.paramTypes = paramTypesTmp;
			newFunction.optionalParamsTypes.clear();
			newFunction.optionalParamsValues.clear();
			functionTable[$2.str] = newFunction;

			currentParamInsertionOrder.clear();
		}
		// set current function return type
		currentReturnType = $1.type;
		// set current function name
		$$.str = $2.str;
		$$.type = $1.type;
	}
	| TYPE ID LPAREN FUNC_DEF_ARGLIST_OPT RPAREN {

	}
	| TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEF_ARGLIST_OPT RPAREN {

	}
;

FUNC_DEF_ARGLIST_OPT : FUNC_DEF_ARGLIST_OPT COMMA DCL_OPT_VAL {

	}
	| DCL_OPT_VAL{ 

	}
;

DCL_OPT_VAL : ID ASSIGN NUM COLON OPTIONAL TYPE { 
		// cant declare void
	}
	| ID ASSIGN NUM COMMA DCL_OPT_VAL { 
		// cant declare void
	}
;

// function argument list rules, insertion to symbol table made in DCL
FUNC_ARGLIST : FUNC_ARGLIST COMMA DCL {
		cerr << "Function argument '" << $3.str << "' of type " << $3.type << endl;
		// insert parameters to currentParamInsertionOrder
		for (int i = 0; i < tmpParamInsertionOrder.size(); i++){
			currentParamInsertionOrder.push_back(tmpParamInsertionOrder[i]);
		}
		tmpParamInsertionOrder.clear();
		vector<Type> paramTypesTmp = $3.paramTypes;
		reverse(paramTypesTmp.begin(), paramTypesTmp.end());
		$$.paramTypes = merge($1.paramTypes, paramTypesTmp);
		$1.paramTypes.clear();
		$3.paramTypes.clear();

	}
	| DCL { 
		cerr << "Function argument '" << $1.str << "' of type " << $1.type << endl;
		for (int i = 0; i < tmpParamInsertionOrder.size(); i++){
			currentParamInsertionOrder.push_back(tmpParamInsertionOrder[i]);
		}
		tmpParamInsertionOrder.clear();
		$$.paramTypes = $1.paramTypes;
		reverse($$.paramTypes.begin(), $$.paramTypes.end());
	}
;

// block rules
BLK : LBRACE OPEN_SCOPE STLIST M CLOSE_SCOPE RBRACE { 
	cerr << "Block parsed" << endl;
}
;

OPEN_SCOPE : { 
		// open scope
		cerr << "Scope opened with depth" << currentBlockDepth << endl;
		currentBlockDepth++;
	} %empty
;

CLOSE_SCOPE : { 
		// remove variables from symbol table in current scope
		cerr << "Scope closed with depth" << currentBlockDepth << endl;
		for (map<string, Symbol>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++){
			if (it->second.depth == currentBlockDepth){
				it->second.type.erase(currentBlockDepth);
				it->second.offset.erase(currentBlockDepth);
				it->second.depth--;
			}
		}
		// close scope
		currentBlockDepth--;
	} %empty
;

// declaration rules 
// function_name (a: type, b:type, c:type, a:type)
DCL : ID COLON TYPE {
		cerr << "Variable '" << $1.str << "' declared with type " << $3.type << endl;
		// cant declare void
		if ($3.type == void_t){
			printSemanticError("Can't declare void");
		}
		// check if the variable isnt in the function list parameters
		if (find(currentParamInsertionOrder.begin(), currentParamInsertionOrder.end(), $1.str) != currentParamInsertionOrder.end()){
			printSemanticError("Variable '" + $1.str + "' already declared as a parameter");
		}
		previousScopeOffset = currentScopeOffset;
		$$.str = $1.str;
		$$.type = $3.type;
		$$.offset = currentScopeOffset;
		$$.paramTypes.push_back($3.type);

		// check if the variable is already declared
		if (symbolTable.find($1.str) == symbolTable.end()){
			// not found in symbol table, insert it
			Symbol newSymbol;
			newSymbol.depth = currentBlockDepth;
			newSymbol.type[currentBlockDepth] = $3.type;
			newSymbol.offset[currentBlockDepth] = currentScopeOffset;
			currentScopeOffset += 4;
			symbolTable[$1.str] = newSymbol;
			tmpParamInsertionOrder.push_back($1.str);
		}
		else { // found in symbol table
			// check if the variable is already declared in the current scope
			if (symbolTable[$1.str].depth == currentBlockDepth){
				printSemanticError("Variable '" + $1.str + "' already declared in the same scope");
			}
			else {
				symbolTable[$1.str].depth = currentBlockDepth;
				symbolTable[$1.str].type[currentBlockDepth] = $3.type;
				symbolTable[$1.str].offset[currentBlockDepth] = currentScopeOffset;
				currentScopeOffset += 4;
			}

		}

	} // variable: int
	| ID COMMA DCL { 
		cerr << "Variable '" << $1.str << "' declared with type " << $3.type << endl;
		// cant declare void
		if ($3.type == void_t){
			printSemanticError("Can't declare void");
		}
		// check if the variable isnt in the function list parameters
		if (find(currentParamInsertionOrder.begin(), currentParamInsertionOrder.end(), $1.str) != currentParamInsertionOrder.end()){
			printSemanticError("Variable '" + $1.str + "' already declared as a parameter");
		}

		if (find(tmpParamInsertionOrder.begin(), tmpParamInsertionOrder.end(), $1.str) != tmpParamInsertionOrder.end()){
			printSemanticError("Variable '" + $1.str + "' already declared as a parameter");
		}

		$$.str = $1.str;
		$$.type = $3.type;
		$$.offset = currentScopeOffset;
		$$.paramTypes = $3.paramTypes;
		$$.paramTypes.push_back($3.type);
		if (symbolTable.find($1.str) == symbolTable.end()){
			// not found in symbol table, insert it
			Symbol newSymbol;
			newSymbol.depth = currentBlockDepth;
			newSymbol.type[currentBlockDepth] = $3.type;
			newSymbol.offset[currentBlockDepth] = currentScopeOffset;
			currentScopeOffset += 4;
			symbolTable[$1.str] = newSymbol;
			tmpParamInsertionOrder.push_back($1.str);
		}
		else { // found in symbol table
			// check if the variable is already declared in the current scope
			if (symbolTable[$1.str].depth == currentBlockDepth){
				printSemanticError("Variable '" + $1.str + "' already declared in the same scope");
			}
			else {
				symbolTable[$1.str].depth = currentBlockDepth;
				symbolTable[$1.str].type[currentBlockDepth] = $3.type;
				symbolTable[$1.str].offset[currentBlockDepth] = currentScopeOffset;
				currentScopeOffset += 4;
			}
		}
	} // var1, var2, var3: int
;

// type rules
TYPE : INT { 
		cerr << "Type int" << endl;
		$$.type = int_t;
	}
	| FLOAT { 
		cerr << "Type float" << endl;
		$$.type = float_t;
	}
	| VOID { 
		cerr << "Type void" << endl;
		$$.type = void_t;
	}
;

// statement list rules
STLIST : STLIST STMT M {
		cerr << "Statement parsed" << endl;
		buffer->backpatch($2.nextList, $3.quad);
	}
	| /* empty */ {} %empty
;

// statement rules
// a, b, c, d, e: int
STMT : 	DCL SEMICOLON {
		cerr << "Variable declared" << endl;
		tmpParamInsertionOrder.clear();
		currentParamInsertionOrder.clear();
		int offsetIncrease = currentScopeOffset - previousScopeOffset;
		buffer->emit("ADD2I I2 I2 " + intToString(offsetIncrease));
	}
	| ASSN {
		cerr << "Assignment" << endl;
	}
	| EXP SEMICOLON {
		cerr << "Expression" << endl;
		if ($1.type != void_t){
			// cast exp to void

		}
	}
	| CNTRL { 
		cerr << "Control flow" << endl;
		$$.nextList = $1.nextList;
   	}
	| READ {
		cerr << "Read" << endl;
	}
	| WRITE {
		cerr << "Write" << endl;
	}
	| RETURN {
		cerr << "Return" << endl;
	}
	| BLK {
		cerr << "Block" << endl;
	}
;

// return, write, read, assignment rules
RETURN : RETURN_ EXP SEMICOLON { 
	cerr << "Return statement of type " << $2.type << endl;
	if (currentReturnType != $2.type){
		printSemanticError("Return type mismatch");
	}
	else if (currentReturnType == void_t){
		printSemanticError("Can't return void");
	}
	$$.type = $2.type;
	$$.regNum = $2.regNum;
	// int returnValSize = 4;
	if ($2.type == int_t){
		// store integer
		buffer->emit("STORI I" + intToString($$.regNum) + " I1 -4");
	}
	else if ($2.type == float_t){
		// store float
		// convert I1 address to float
		buffer->emit("CITOF F1 I1");
		buffer->emit("STORF F" + intToString($2.regNum) + " F1 -4");
	}
	buffer->emit("RETRN");
}
	| RETURN_ SEMICOLON { 
		cerr << "Return statement of type void" << endl;
		if (currentReturnType != void_t){
			printSemanticError("Return type mismatch");
		}
		$$.type = void_t;
		buffer->emit("RETRN");
	}
;

WRITE : WRITE_ LPAREN EXP RPAREN SEMICOLON {
		cerr << "Write statement of type " << $3.type << endl;
		// check if EXP is void
		if ($3.type == void_t){
			printSemanticError("Can't write void");
		}
		if ($3.type == int_t){
			// write integer
			buffer->emit("PRNTI I" + intToString($3.regNum));
		}
		else if ($3.type == float_t){
			// write float
			buffer->emit("PRNTF F" + intToString($3.regNum));
		}
 	}
	| WRITE_ LPAREN STR RPAREN SEMICOLON { 
		cerr << "Write statement of type string" << endl;
		// write string
		for (int i = 0; i < $3.str.length(); i++){
			char c = $3.str[i];
			if ($3.str[i] == '\\'){
				if ($3.str[i+1] == 'n'){
					c = '\n';
					i++;
				}
				else if ($3.str[i+1] == 't'){
					c = '\t';
					i++;
				}
				else if ($3.str[i+1] == 'r'){
					c = '\r';
					i++;
				}
				else if ($3.str[i+1] == '"'){
					c = '\"';
					i++;
				}
			}
			int ascii = (int)c;
			buffer->emit("PRNTC " + intToString(ascii));
		}
	}
;
/* example
ADD2I I3 I1 0 // I3 = I1 + 0 (calculate address of I1, done by LVAL)
READI I4 	  // read integer f
STORI I4 I3 0
*/
READ : READ_ LPAREN LVAL RPAREN SEMICOLON { 
		cerr << "Read statement of type " << $3.type << endl;
		// check if LVAL is void
		if ($3.type == void_t){
			printSemanticError("Can't read void");
		}
		if ($3.type == int_t){
			int tempReg = currentScopeRegsNumInt++;
			// read integer
			buffer->emit("READI I" + intToString(tempReg));
			// store integer
			buffer->emit("STORI I" + intToString(tempReg) + " I" + intToString($3.regNum) + " 0");
		}
		else if ($3.type == float_t){
			int tempRegConvert = currentScopeRegsNumFloat++;
			int tempRegRead = currentScopeRegsNumFloat++;
			// read float
			buffer->emit("READF F" + intToString(tempRegRead));
			// convert LVAL address to float
			buffer->emit("CITOF F" + intToString(tempRegConvert) + " I" + intToString($3.regNum));
			// store float
			buffer->emit("STORF F" + intToString(tempRegRead) + " F" + intToString(tempRegConvert) + " 0");
		}
	}

;
// assignment rules
/* example
ADD2I I3 I1 0 // I3 = I1 + 0 (calculate address of ID, done by LVAL)
STORI I4 I3 0
*/
ASSN : LVAL ASSIGN EXP SEMICOLON { 
		cerr << "Assignment of type " << $1.type << " to type " << $3.type << endl;
		// check if types are the same
		if ($1.type != $3.type){
			printSemanticError("Type mismatch in assignment");
		}
		// check if LVAL is void
		if ($1.type == void_t){
			printSemanticError("Can't assign void");
		}
		if ($1.type == int_t){
			// store integer
			buffer->emit("STORI I" + intToString($3.regNum) + " I" + intToString($1.regNum) + " 0");
		}
		else if ($1.type == float_t){
			int tempReg = currentScopeRegsNumFloat++;
			// convert LVAL address to float
			buffer->emit("CITOF F" + intToString(tempReg) + " I" + intToString($1.regNum));
			// store float
			buffer->emit("STORF F" + intToString($3.regNum) + " F" + intToString(tempReg) + " 0");
		}
	}
;

LVAL : ID { 
		cerr << "LVAL of type of id: " << $1.str << endl;
		// check if the variable is declared
		if (symbolTable.find($1.str) == symbolTable.end()){
			// not found in symbol table
			printSemanticError("Variable '" + $1.str + "' not declared");
		}
		int depth = symbolTable[$1.str].depth;
		$$.type = symbolTable[$1.str].type[depth];
		$$.offset = symbolTable[$1.str].offset[depth];
		if ($$.type == void_t) {
			printSemanticError("Variable '" + $1.str + "' is void");
		}
		$$.regNum = currentScopeRegsNumInt++;
		// calculate address of ID
		buffer->emit("ADD2I I" + intToString($$.regNum) + " I1 " + intToString($$.offset));
	}
;

// control flow rules
CNTRL : IF BEXP THEN M STMT ELSE N M STMT { 
		cerr << "If else statement" << endl;
		// if BEXP is true then execute STMT
		buffer->backpatch($2.trueList, $4.quad);
		// if BEXP is false then execute ELSE STMT
		buffer->backpatch($2.falseList, $8.quad);
		// if STMT is done, go to nextlist of CNTRL (including falling out)
		$$.nextList = merge<int>($5.nextList, $7.nextList);
		// also go to nextlist of CNTRL if ELSE STMT is done
		$$.nextList = merge<int>($$.nextList, $9.nextList);
		// clear merged lists
		$2.falseList.clear();
		$7.nextList.clear();
		$9.nextList.clear();
	}
	| IF BEXP THEN M STMT { 
		cerr << "If statement" << endl;
		// if BEXP is true then execute STMT
		buffer->backpatch($2.trueList, $4.quad);
		// if BEXP is false or STMT is done, go to nextlist of CNTRL
		$$.nextList = merge<int>($2.falseList, $5.nextList);
		// clear merged lists
		$2.falseList.clear();
		$5.nextList.clear();

	}
	| WHILE M BEXP DO M STMT {
		cerr << "While statement" << endl;
		// if BEXP is true then execute STMT
		buffer->backpatch($3.trueList, $5.quad);
		// when STMT is done, go back to BEXP
		buffer->backpatch($6.nextList, $2.quad);
		// if BEXP is false, go out of the loop
		$$.nextList = $3.falseList;
		// catch falling out of loop
		buffer->emit("UJUMP " + intToString($2.quad));

	}
;

// boolean and expression rules
BEXP : BEXP OR M BEXP { 
		cerr << "OR" << endl;
		buffer->backpatch($1.falseList, $3.quad);
		$$.falseList = $4.falseList;
		$$.trueList = merge<int>($1.trueList, $4.trueList);
		$1.trueList.clear();
		$4.trueList.clear();
	}
	| BEXP AND M BEXP { 
		cerr << "AND" << endl;
		buffer->backpatch($1.trueList, $3.quad);
		$$.falseList = merge<int>($1.falseList, $4.falseList);
		$$.trueList = $4.trueList;
		$1.falseList.clear();
		$4.falseList.clear();
	}
	| NOT BEXP { 
		cerr << "NOT" << endl;
		$$.trueList = $2.falseList;
		$$.falseList = $2.trueList;
	}
	| EXP RELOP EXP { 
		cerr << "RELOP " << $2.str << endl;
		if ($1.type == void_t || $3.type == void_t){
			printSemanticError("Can't compare void");
		}
		else if ($1.type != $3.type){
			printSemanticError("Type mismatch in comparison");
		}
		$$.type = int_t;
		$$.regNum = currentScopeRegsNumInt++;
		if ($1.type == int_t){
			// Set BREQZ / BNEQZ for backpatching
			$$.falseList.push_back(buffer->nextquad() + 1);
			// Set UJUMP for backpatching
			$$.trueList.push_back(buffer->nextquad() + 2);
			if ($2.str == "==") {
				// SEQUI = set equal
				buffer->emit("SEQUI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<>") {
				// SNEQI = set not equal
				buffer->emit("SNEQI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<") {
				// SLETI = set less than
				buffer->emit("SLETI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<=") {
				// if $1 <= $3, then $3 > $1 (SGRTI = set greater than)
				buffer->emit("SGRTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
			else if ($2.str == ">") {
				// SGRTI = set greater than
				buffer->emit("SGRTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == ">=") {
				// if $1 >= $3, then $3 < $1 (SLETI = set less than)
				buffer->emit("SLETI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
		}
		else if ($1.type == float_t) {
			// Set BREQZ / BNEQZ for backpatching
			$$.falseList.push_back(buffer->nextquad() + 2);
			// Set UJUMP for backpatching
			$$.trueList.push_back(buffer->nextquad() + 3);
			int tempReg = currentScopeRegsNumFloat++;
			if ($2.str == "==") {
				// SEQUF = set equal
				buffer->emit("SEQUF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
															  + " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<>") {
				// SNEQF = set not equal
				buffer->emit("SNEQF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
															  + " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<") {
				// SLETF = set less than
				buffer->emit("SLETF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
															  + " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<=") {
				// if $1 <= $3, then $3 > $1 (SGRTF = set greater than)
				buffer->emit("SGRTF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
			else if ($2.str == ">") {
				// SGRTF = set greater than
				buffer->emit("SGRTF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == ">=") {
				// if $1 >= $3, then $3 < $1 (SLETF = set less than)
				buffer->emit("SLETF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
		}
		buffer->emit("UJUMP "); // trueList
	}
	| LPAREN BEXP RPAREN { 
		cerr << "Parenthesis on BEXP" << endl;
		$$.trueList = $2.trueList;
		$$.falseList = $2.falseList;
	}
;

// expression rules
EXP : EXP ADDOP EXP { 
		cerr << "ADDOP " << $2.str << endl;
		if ($1.type == void_t || $3.type == void_t){
			printSemanticError("Can't add void");
		}
		else if ($1.type != $3.type){
			printSemanticError("Type mismatch in addition");
		}
		$$.type = $1.type;
		if ($1.type == int_t){
			$$.regNum = currentScopeRegsNumInt++;
			if ($2.str == "+") {
				buffer->emit("ADD2I I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
			else { // $2.str == "-"
				buffer->emit("SUBTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
		}
		else if ($1.type == float_t){
			$$.regNum = currentScopeRegsNumFloat++;
			if ($2.str == "+") {
				buffer->emit("ADD2F F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
			else { // $2.str == "-"
				buffer->emit("SUBTF F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
		}
	}
	| EXP MULOP EXP {
		cerr << "MULOP " << $2.str << endl;
		if ($1.type == void_t || $3.type == void_t){
			printSemanticError("Can't multiply void");
		}
		else if ($1.type != $3.type){
			printSemanticError("Type mismatch in multiplication");
		}
		$$.type = $1.type;
		if ($1.type == int_t){
			$$.regNum = currentScopeRegsNumInt++;
			if ($2.str == "*") {
				buffer->emit("MULTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
			else { // $2.str == "/"
				buffer->emit("DIVDI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
		}
		else if ($1.type == float_t){
			$$.regNum = currentScopeRegsNumFloat++;
			if ($2.str == "*") {
				buffer->emit("MULTF F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
			else { // $2.str == "/"
				buffer->emit("DIVDF F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
			
		}
	}
	| LPAREN EXP RPAREN { 
		cerr << "Parenthesis on EXP" << endl;
		$$ = $2;
	}
	| LPAREN TYPE RPAREN EXP { 
		cerr << "Cast from " << $4.type << " to " << $2.type << endl;
		// check if the types arent void
		if (($4.type == void_t) && ($2.type != void_t)){
			printSemanticError("Can't cast from void to non-void");
		}

		if ($2.type == $4.type){
			$$ = $4;
		}
		else if ($2.type == int_t && $4.type == float_t){
			$$.type = $2.type;
			$$.offset = $4.offset;
			// convert float to int
			$$.regNum = currentScopeRegsNumInt++;
			buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString($4.regNum));
			
		}
		else if ($2.type == float_t && $4.type == int_t){
			$$.type = $2.type;
			$$.offset = $4.offset;
			// convert int to float
			$$.regNum = currentScopeRegsNumFloat++;
			buffer->emit("CITOF F" + intToString($$.regNum) + " I" + intToString($4.regNum));
		}
		else { // $2.type == void_t
			$$.type = $2.type;
		}
	}
	| ID { 
		cerr << "ID " << $1.str << " into EXP" << endl;
		// check if in symbol table with $1
	  	if (symbolTable.find($1.str) == symbolTable.end()){
			// not found in symbol table
			printSemanticError("Variable " + $1.str + " not declared");
		}
		string name = $1.str;
		int depth = symbolTable[name].depth;
		$$.type = symbolTable[name].type[depth];
		if ($$.type == int_t){
			$$.regNum = currentScopeRegsNumInt++;
			$$.offset = symbolTable[name].offset[depth];
			buffer->emit("LOADI I" + intToString($$.regNum) + " I1 " + intToString($$.offset));
		}
		else if ($$.type == float_t){
			$$.regNum = currentScopeRegsNumFloat++;
			$$.offset = symbolTable[name].offset[depth];
			// load I1 into F1
			buffer->emit("CITOF F1 I1");
			// load float
			buffer->emit("LOADF F" + intToString($$.regNum) + " F1 " + intToString($$.offset));
		}
	}
	| NUM { 
		cerr << "NUM " << $1.value << " into EXP" << endl;
		$$ = $1;
	}
	| CALL {
		cerr << "Function call into EXP" << endl;
		// the result of the function call is in $1
		$$.type = $1.type;
		if ($$.type != void_t){
			$$.regNum = $1.regNum;
		}
	}
;

// number rules
NUM : INTEGERNUM { 
		cerr << "Integer number " << $1.str << endl;
		$$.type = int_t;
		$$.regNum = currentScopeRegsNumInt++;
		$$.value = $1.str;
		buffer->emit("COPYI I" + intToString($$.regNum) + " " + $1.str);
	}
	| REALNUM { 
		cerr << "Real number " << $1.str << endl;
		$$.type = float_t;
		$$.regNum = currentScopeRegsNumFloat++;
		$$.value = $1.str;
		buffer->emit("COPYF F" + intToString($$.regNum) + " " + $1.str);
	}
;

// function call rules
CALL : ID LPAREN CALL_ARGS RPAREN {
		cerr << "Function call of " << $1.str << endl;
		string functionName = $1.str;
		// check if the function is declared
		if (functionTable.find(functionName) == functionTable.end()){
			// not found in symbol table
			printSemanticError("Function '" + functionName + "' not declared");
		}
		// check if the number of arguments match (including optional arguments)
		int totalArgs = functionTable[functionName].paramTypes.size(); // total number of arguments including optional
		int inputedArgs = $3.paramTypes.size(); // number of inputed arguments
		int maxOptionalArgs = functionTable[functionName].optionalParamsNum;
		cerr << "Total args: " << totalArgs << ", inputed args: " << inputedArgs << ", max optional args: " << maxOptionalArgs << endl;
		if ((inputedArgs < totalArgs - maxOptionalArgs) || (inputedArgs > totalArgs)){
			printSemanticError("Number of arguments in function call of '" + functionName + "' doesn't match");
		}

		// check if the types of arguments match
		for (int i = 0; i < inputedArgs; i++){
			if ($3.paramTypes[i] != functionTable[functionName].paramTypes[i]){
				printSemanticError("Type mismatch in function call of '" + functionName + "'");
			}
		}
		
		// we only use types of 4 bytes (int, float), everything is alligned to 4 bytes
		// save all used registers to stack
		int offset = 0;
		// calculate num of optional arguments passed
		int numOptionalArgsPassed = inputedArgs - (totalArgs - maxOptionalArgs);
		int tempReg = currentScopeRegsNumInt++;
		buffer->emit("COPYI I" + intToString(tempReg) + " " + intToString(numOptionalArgsPassed));
		// set F2 to be the same as I2
		buffer->emit("CITOF F2 I2");
		int maxRegs = max(currentScopeRegsNumInt, currentScopeRegsNumFloat);
		for (int i = 0; i < maxRegs; i++){
			if (i < currentScopeRegsNumInt){
				buffer->emit("STORI I" + intToString(i) + " I2 " + intToString(offset));
			}
			if (i < currentScopeRegsNumFloat){
				buffer->emit("STORF F" + intToString(i) + " F2 " + intToString(offset));
			}
			offset += 4;
		}
		offset += 8; // 4 bytes for return value and 4 bytes for num of optional arguments passed

		int paramsCurrentOffset = -8;
		int paramCount = $3.paramRegs.size();
		vector<Type> paramTypes = $3.paramTypes;
		vector<int> paramRegs = $3.paramRegs;
		vector<int> paramOffsets;
		
		if (numOptionalArgsPassed > 0) {
			buffer->emit("STORI");
		}
		// calculate the size of the stack with all the arguments
		for (int i = 0; i < paramCount; i++){
			if (paramTypes[i] == int_t){
				offset += 4;
				paramsCurrentOffset -= 4;
			}
			else if (paramTypes[i] == float_t){
				offset += 4;
				paramsCurrentOffset -= 4;
			}
			paramOffsets.push_back(paramsCurrentOffset);
		}
		// set the stack pointer (I2) to the top of the stack
		buffer->emit("ADD2I I2 I2 " + intToString(offset));
		currentScopeOffset += offset;
		// set I1 to the address of the first argument
		buffer->emit("COPYI I1 I2");
		buffer->emit("CITOF F1 I1");

		// store arguments to the stack
		for (int i = 0; i < paramCount; i++){
			if (paramTypes[i] == int_t){
				buffer->emit("STORI I" + intToString(paramRegs[i]) + " I1 " + intToString(paramOffsets[i]));
			}
			else if (paramTypes[i] == float_t){
				buffer->emit("STORF F" + intToString(paramRegs[i]) + " F1 " + intToString(paramOffsets[i]));
			}
		}
		// store num of optional arguments passed
		buffer->emit("STORI I" + intToString(tempReg) + " I1 -8");

		// call function
		// add the address of the function call to the calling addresses of the function
		functionTable[functionName].callingAddresses.push_back(buffer->nextquad());
		buffer->emit("JLINK ");

		// back from function call, restore registers

		// set the stack pointer (I2) to the top of the stack
		buffer->emit("COPYI I2 I1");

		// set return value to a register
		if (functionTable[functionName].returnType == int_t){
			$$.type = int_t;
			$$.regNum = currentScopeRegsNumInt;
			buffer->emit("LOADI I" + intToString($$.regNum) + " I1 -4");
		}
		else if (functionTable[functionName].returnType == float_t){
			$$.type = float_t;
			$$.regNum = currentScopeRegsNumFloat;
			buffer->emit("CITOF F1 I1");
			buffer->emit("LOADF F" + intToString($$.regNum) + " F1 -4");
		}
		else {
			$$.type = void_t;
		}
		// close the stack
		buffer->emit("SUBTI I2 I2 " + intToString(offset));
		buffer->emit("CITOF F2 I2");

		// restore registers
		offset = 0;
		// LOADI for all integer registers (no need to restore return value, it's already restored)
		for (int i = 0; i < maxRegs; i++){
			// skip I2
			if (i == 2){
				offset += 4;
				continue;
			}
			if (i < currentScopeRegsNumFloat){
				buffer->emit("LOADF F" + intToString(i) + " F2 " + intToString(offset));
			}
			if (i < currentScopeRegsNumInt){
				buffer->emit("LOADI I" + intToString(i) + " I2 " + intToString(offset));
			}
			offset += 4;
		}

		// LOADF for all float registers (no need to restore return value, it's already restored)

		if (functionTable[functionName].returnType == int_t){
			currentScopeRegsNumInt++;
		}
		else if (functionTable[functionName].returnType == float_t){
			currentScopeRegsNumFloat++;
		}
	}
;

// function call argument rules
CALL_ARGS : CALL_ARGLIST {
		cerr << "Function call arguments" << endl;
		// insert arguments to CALL_ARGS
		$$.paramTypes = $1.paramTypes;
		$$.paramRegs = $1.paramRegs;
		// clear CALL_ARGLIST
		$1.paramTypes.clear();
		$1.paramRegs.clear();
	}
	| /* empty */ {} %empty
;

// function call argument list rules
CALL_ARGLIST : CALL_ARGLIST COMMA EXP {
		cerr << "Function call argument list" << endl;
		// insert arguments to CALL_ARGLIST from CALL_ARGLIST
		$$.paramTypes = $1.paramTypes;
		$$.paramRegs = $1.paramRegs;
		// insert arguments to CALL_ARGLIST from EXP
		$$.paramTypes.push_back($3.type);
		$$.paramRegs.push_back($3.regNum);
		// clear CALL_ARGLIST
		$1.paramTypes.clear();
		$1.paramRegs.clear();
	}
	| EXP {
		cerr << "Function call argument list (EXP)" << endl;
		// arguments cant be void
		$$.paramTypes.push_back($1.type);
		$$.paramRegs.push_back($1.regNum);
	}
;

M : /* empty */ { 
		cerr << "M" << endl;
		$$.quad = buffer->nextquad();
		cerr << "M quad: " << $$.quad << endl;
	} %empty
;

N : /* empty */ { 	
		cerr << "N" << endl;
		$$.nextList.push_back(buffer->nextquad());
		buffer->emit("UJUMP ");
	} %empty
;
%%

void yyerror(char const * message)
{
    printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
    exit(SYNTAX_ERROR);
}

void printSemanticError(string error){
	cout << "Semantic error: " << error << " in line number " << yylineno << endl;
	exit(SEMANTIC_ERROR);
}

void printOperationalError(string error){
	cout << "Operational error: " << error << endl;
	exit(OPERATIONAL_ERROR);
}

int main(int argc, char *argv[])
{

    if (argc != 2) {
		printOperationalError("invalid number of arguments");
	}
	string inputFileName = argv[1];

	extern FILE *yyin;
	// Open the input file 
	yyin = fopen(argv[1], "r");
	if (yyin == NULL) {
		printOperationalError("cannot open input file");
	}
	size_t lastindex;

	lastindex = inputFileName.find_last_of(".");
	if (inputFileName.substr(lastindex) != ".cmm") {
		printOperationalError("invalid file type. expecting '.cmm' extension");
	}
	
    // Initialize the buffer
	buffer = &mainBuffer;

    int rc;
    cerr << "Parsing started" << endl;
    rc = yyparse();
    cerr << "Parsing finished with return code " << rc << endl;
    if (rc == 0) { // Parsed successfully

        mainBuffer.emit_front("</header>");

        string imp = "<implemented>";
        string uimp = "<unimplemented>";

        for(map<string, Function>::iterator it = functionTable.begin(); it != functionTable.end(); it++) {
            if (it->second.implemented) {
                // Add the function to the implemented list (function name, address of implementation)
                imp += " " + it->first + "," + intToString(it->second.address);
            }
            else {
                // Add the function to the unimplemented list (function name, list of calling addresses)
                uimp += " " + it->first;
                for (int i = 0; i < it->second.callingAddresses.size(); i++) {
                    uimp += "," + intToString(it->second.callingAddresses[i]);
                }
            }
        }

        mainBuffer.emit_front(imp);
        mainBuffer.emit_front(uimp);

        mainBuffer.emit_front("<header>");

        ofstream rskFile;
        string outputFileName;
        outputFileName = inputFileName.substr(0, lastindex) + ".rsk";
        size_t found = outputFileName.find_last_of("/\\");
        outputFileName = outputFileName.substr(found+1);

        rskFile.open(outputFileName.c_str());

        rskFile << mainBuffer.printBuffer();
        rskFile.close();

    }
    yylex_destroy();
    return rc;
}
