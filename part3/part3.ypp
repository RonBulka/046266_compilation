%{
	#include "part3_helpers.hpp"

    using namespace std;
    
	extern char *yytext;
	extern int yylineno;
	extern int yylex();
	
	void yyerror(char const * message);
	void printSemanticError(string error);
	void printOperationalError(string error);
%}

// declare tokens we get from lexer and their types and their associativity
%token INT FLOAT VOID WRITE_ READ_ OPTIONAL WHILE DO IF RETURN_ COLON SEMICOLON ID INTEGERNUM REALNUM STR 

%right THEN
%right ELSE

%left COMMA
%right ASSIGN
%left OR
%left AND
%left RELOP
%left ADDOP
%left MULOP
%right LPAREN RPAREN NOT
%left LBRACE RBRACE

%%
// define grammar rules
// root rule
PROGRAM : FDEFS { 
		// after parsing the whole program, we need to fill in calls to functions we have defined
		// fill in the calls to functions
		for (auto it = functionTable.begin(); it != functionTable.end(); it++){
			int impAddress = it->second.address;
			buffer->backpatch(it->second.callingAddresses, impAddress);
		}
	}
;

FDEFS :   FDEFS FUNC_DEF_API M BLK {
		// function entry in function table is already done in FUNC_DEF_API
		// check if the function is already defined
		if (functionTable[$2.str].defined){
			printSemanticError("Function '" + $2.str + "' already defined");
		}
		else { // if the function is not defined, 
			// set the function as defined
			functionTable[$2.str].defined = true;
			// set the function address
			functionTable[$2.str].address = $3.quad;
		}
		// catch void return
		buffer->emit("RETRN");
		// clear symbol table
		symbolTable.clear();
		$2.paramTypes.clear();
		// clear current scope registers
		currentScopeRegsNumInt = 3;
		currentScopeRegsNumFloat = 3;
		// clear current scope offset
		currentScopeOffset = 0;
	}
	| FDEFS FUNC_DEC_API {
		// $2 is a function declaration, its already inserted in the function table by FUNC_DEC_API
		// check if the function is not defined
		if (!functionTable[$2.str].defined){
			functionTable[$2.str].address = -1;
		}
		// clear symbol table
		symbolTable.clear();
	}
	| /* empty */ { } %empty
;

// function declaration rules, create new function instance and add it to function table
FUNC_DEC_API :   TYPE ID LPAREN RPAREN SEMICOLON {
		
 	}
	| TYPE ID LPAREN FUNC_ARGLIST RPAREN SEMICOLON { 

	}
	| TYPE ID LPAREN FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { }
	| TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { }
;

FUNC_DEC_ARGLIST_OPT :   FUNC_DEC_ARGLIST_OPT COMMA DCL_OPT { 

	}
	| DCL_OPT { 

	}
;

DCL_OPT : ID COLON OPTIONAL TYPE { 

	}
	| ID COMMA DCL_OPT{ 

	}
;

// function definition rules
FUNC_DEF_API : TYPE ID LPAREN RPAREN {
		// might need to change this
		if (functionTable->find($2.str) != functionTable->end()){
			// found in function table
			// if not defined, but declared check if the return type and parameters match
			if (!functionTable[$2.str].defined){
				// check if return type matches
				if (functionTable[$2.str].returnType != $2.type){
					printSemanticError("Function '" + $2.str + "' already declared with different return type");
				}
				// check if parameters match
				else if (functionTable[$2.str].paramTypes != $2.paramTypes){
					printSemanticError("Function '" + $2.str + "' already declared with different parameters");
				}
				// check if the number of optional arguments match
				else if (functionTable[$2.str].maxOptionalArgs != $2.maxOptionalArgs){
					printSemanticError("Function '" + $2.str + "' already declared with different number of optional arguments");
				}
			}
			// check if return type matches
			if (functionTable[$2.str].returnType != $2.type){
				printSemanticError("Function '" + $2.str + "' already declared with different return type");
			}
			// check if parameters match
			else if (functionTable[$2.str].paramTypes != $2.paramTypes){
				printSemanticError("Function '" + $2.str + "' already declared with different parameters");
			}
			// if the function is defined, 
			else{
				
			}
		}
	}
	| TYPE ID LPAREN FUNC_ARGLIST RPAREN {

	}
	| TYPE ID LPAREN FUNC_DEF_ARGLIST_OPT RPAREN {

	}
	| TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEF_ARGLIST_OPT RPAREN {

	}
;

FUNC_DEF_ARGLIST_OPT : FUNC_DEF_ARGLIST_OPT COMMA DCL_OPT_VAL {

	}
	| DCL_OPT_VAL{ 

	}
;

DCL_OPT_VAL : ID ASSIGN NUM COLON OPTIONAL TYPE { 
		// cant declare void
	}
	| ID ASSIGN NUM COMMA DCL_OPT_VAL { 
		// cant declare void
	}
;

// function argument list rules, insertion to symbol table made in DCL
FUNC_ARGLIST : FUNC_ARGLIST COMMA DCL {
		// insert parameters to currentParamInsertionOrder ()
	}
	| DCL { 
		
	}
;

// block rules
BLK : LBRACE OPEN_SCOPE STLIST M CLOSE_SCOPE RBRACE { }
;

OPEN_SCOPE : { 
		// open scope
		currentBlockDepth++;
	}
;

CLOSE_SCOPE : { 
		// remove variables from symbol table in current scope
		for (auto it = symbolTable->begin(); it != symbolTable->end(); it++){
			if (it->second.depth == currentBlockDepth){
				it->second.type.erase(currentBlockDepth);
				it->second.offset.erase(currentBlockDepth);
				it->second.depth--;
			}
		}
		// close scope
		currentBlockDepth--;
	}
;

// declaration rules
DCL : ID COLON TYPE { 
		// cant declare void

	} // variable: int
	| ID COMMA DCL { 
		// cant declare void
		
	} // var1, var2, var3: int
;

// type rules
TYPE : INT { 
		$$.type = int_t;
	}
	| FLOAT { 
		$$.type = float_t;
	}
	| VOID { 
		$$.type = void_t;
	}
;

// statement list rules
STLIST : STLIST STMT M {
		buffer->backpatch($2.nextList, $3.quad);
	}
	| /* empty */ {} %empty
;

// statement rules
STMT : 	DCL SEMICOLON {}
	   | ASSN {}
	   | EXP SEMICOLON {}
	   | CNTRL { 
			$$.nextList = $2.nextList;
	   }
	   | READ {}
	   | WRITE {}
	   | RETURN {}
	   | BLK {}
;

// return, write, read, assignment rules
RETURN : RETURN_ EXP SEMICOLON { 
	if (currentReturnType != $2.type){
		printSemanticError("Return type mismatch");
	}
	else if (currentReturnType == void_t){
		printSemanticError("Can't return void");
	}
	$$.type = $2.type;
	$$.regNum = $2.regNum;
	// int returnValSize = 4;
	if ($2.type == int_t){
		// store integer
		buffer->emit("STORI I" + intToString($$.regNum) + " I1 -4");
	}
	else if ($2.type == float_t){
		// store float
		// convert I1 address to float
		buffer->emit("CITOF F1 I1");
		buffer->emit("STORF F" + intToString($2.regNum) + " F1 -4");
	}
	buffer->emit("RETRN");
}
	| RETURN_ SEMICOLON { 
		if (currentReturnType != void_t){
			printSemanticError("Return type mismatch");
		}
		$$.type = void_t;
		buffer->emit("RETRN");
	}
;

WRITE : WRITE_ LPAREN EXP RPAREN SEMICOLON {
		// check if EXP is void
		if ($3.type == void_t){
			printSemanticError("Can't write void");
		}
		if ($3.type == int_t){
			// write integer
			buffer->emit("PRNTI I" + intToString($3.regNum));
		}
		else if ($3.type == float_t){
			// write float
			buffer->emit("PRNTF F" + intToString($3.regNum));
		}
 	}
	| WRITE_ LPAREN STR RPAREN SEMICOLON { 
		// write string
		for (int i = 0; i < $3.str.length(); i++){
			char c = $3.str[i];
			if ($3.str[i] == '\\'){
				if ($3.str[i+1] == 'n'){
					c = '\n';
					i++;
				}
				else if ($3.str[i+1] == 't'){
					c = '\t';
					i++;
				}
				else if ($3.str[i+1] == 'r'){
					c = '\r';
					i++;
				}
				else if ($3.str[i+1] == '"'){
					c = '\"';
					i++;
				}
			}
			int ascii = (int)c;
			buffer->emit("PRNTC " + intToString(ascii));
		}
	}
;
/* example
ADD2I I3 I1 0 // I3 = I1 + 0 (calculate address of I1, done by LVAL)
READI I4 	  // read integer f
STORI I4 I3 0
*/
READ : READ_ LPAREN LVAL RPAREN SEMICOLON { 
		// check if LVAL is void
		if ($3.type == void_t){
			printSemanticError("Can't read void");
		}
		if ($3.type == int_t){
			int tempReg = currentScopeRegsNumInt++;
			// read integer
			buffer->emit("READI I" + intToString(tempReg));
			// store integer
			buffer->emit("STORI I" + intToString(tempReg) + " I" + intToString($3.regNum) + " 0");
		}
		else if ($3.type == float_t){
			int tempRegConvert = currentScopeRegsNumFloat++;
			int tempRegRead = currentScopeRegsNumFloat++;
			// read float
			buffer->emit("READF F" + intToString(tempReg));
			// convert LVAL address to float
			buffer->emit("CITOF F" + intToString(tempRegConvert) + " I" + intToString($3.regNum));
			// store float
			buffer->emit("STORF F" + intToString(tempReg) + " F" + intToString(tempRegConvert) + " 0");
		}
	}

;
// assignment rules
/* example
ADD2I I3 I1 0 // I3 = I1 + 0 (calculate address of ID, done by LVAL)
STORI I4 I3 0
*/
ASSN : LVAL ASSIGN EXP SEMICOLON { 
		// check if types are the same
		if ($1.type != $3.type){
			printSemanticError("Type mismatch in assignment");
		}
		// check if LVAL is void
		if ($1.type == void_t){
			printSemanticError("Can't assign void");
		}
		if ($1.type == int_t){
			// store integer
			buffer->emit("STORI I" + intToString($3.regNum) + " I" + intToString($1.regNum) + " 0");
		}
		else if ($1.type == float_t){
			int tempReg = currentScopeRegsNumFloat++;
			// convert LVAL address to float
			buffer->emit("CITOF F" + intToString(tempReg) + " I" + intToString($1.regNum));
			// store float
			buffer->emit("STORF F" + intToString($3.regNum) + " F" + intToString(tempReg) + " 0");
		}
	}
;

LVAL : ID { 
		// check if the variable is declared
		if (symbolTable->find($1.str) == symbolTable->end()){
			// not found in symbol table
			printSemanticError("Variable '" + $1.str + "' not declared");
		}
		int depth = symbolTable[$1.str].depth;
		$$.type = symbolTable[$1.str].type[depth];
		$$.offset = symbolTable[$1.str].offset[depth];
		if ($$.type == void_t) {
			printSemanticError("Variable '" + $1.str + "' is void");
		}
		$$.regNum = currentScopeRegsNumInt++;
		// calculate address of ID
		buffer->emit("ADD2I I" + intToString($$.regNum) + " I1 " + intToString($$.offset));
	}
;

// control flow rules
CNTRL : IF BEXP THEN M STMT ELSE N M STMT { 
		// if BEXP is true then execute STMT
		buffer->backpatch($2.trueList, $4.quad);
		// if BEXP is false then execute ELSE STMT
		buffer->backpatch($2.falseList, $8.quad);
		// if STMT is done, go to nextlist of CNTRL (including falling out)
		$$.nextList = merge<int>($5.nextList, $7.nextList);
		// also go to nextlist of CNTRL if ELSE STMT is done
		$$.nextList = merge<int>($$.nextList, $9.nextList);
		// clear merged lists
		$2.falseList.clear();
		$7.nextList.clear();
		$9.nextList.clear();
	}
	| IF BEXP THEN M STMT { 
		// if BEXP is true then execute STMT
		buffer->backpatch($2.trueList, $4.quad);
		// if BEXP is false or STMT is done, go to nextlist of CNTRL
		$$.nextList = merge<int>($2.falseList, $5.nextList);
		// clear merged lists
		$2.falseList.clear();
		$5.nextList.clear();

	}
	| WHILE M BEXP DO M STMT {
		// if BEXP is true then execute STMT
		buffer->backpatch($3.trueList, $5.quad);
		// when STMT is done, go back to BEXP
		buffer->backpatch($6.nextList, $2.quad);
		// if BEXP is false, go out of the loop
		$$.nextList = $3.falseList;
		// catch falling out of loop
		buffer->emit("UJUMP " + intToString($2.quad));

	}
;

// boolean and expression rules
BEXP : BEXP OR M BEXP { 
		buffer->backpatch($1.falseList, $3.quad);
		$$.falseList = $4.falseList;
		$$.trueList = merge<int>($1.trueList, $4.trueList);
		$1.trueList.clear();
		$4.trueList.clear();
	}
	| BEXP AND M BEXP { 
		buffer->backpatch($1.trueList, $3.quad);
		$$.falseList = merge<int>($1.falseList, $4.falseList);
		$$.trueList = $4.trueList;
		$1.falseList.clear();
		$4.falseList.clear();
	}
	| NOT BEXP { 
		$$.trueList = $2.falseList;
		$$.falseList = $2.trueList;
	}
	| EXP RELOP EXP { 
		if ($1.type == void_t || $3.type == void_t){
			printSemanticError("Can't compare void");
		}
		else if ($1.type != $3.type){
			printSemanticError("Type mismatch in comparison");
		}
		$$.type = int_t;
		$$.regNum = currentScopeRegsNumInt++;
		if ($1.type == int_t){
			// Set BREQZ / BNEQZ for backpatching
			$$.falseList.push_back(buffer->nextquad() + 1);
			// Set UJUMP for backpatching
			$$.trueList.push_back(buffer->nextquad() + 2);
			if ($2.str == "==") {
				// SEQUI = set equal
				buffer->emit("SEQUI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<>") {
				// SNEQI = set not equal
				buffer->emit("SNEQI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<") {
				// SLETI = set less than
				buffer->emit("SLETI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<=") {
				// if $1 <= $3, then $3 > $1 (SGRTI = set greater than)
				buffer->emit("SGRTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
			else if ($2.str == ">") {
				// SGRTI = set greater than
				buffer->emit("SGRTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == ">=") {
				// if $1 >= $3, then $3 < $1 (SLETI = set less than)
				buffer->emit("SLETI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
		}
		else if ($1.type == float_t) {
			// Set BREQZ / BNEQZ for backpatching
			$$.falseList.push_back(buffer->nextquad() + 2);
			// Set UJUMP for backpatching
			$$.trueList.push_back(buffer->nextquad() + 3);
			int tempReg = currectScopeRegsNumFloat++;
			if ($2.str == "==") {
				// SEQUF = set equal
				buffer->emit("SEQUF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
															  + " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<>") {
				// SNEQF = set not equal
				buffer->emit("SNEQF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
															  + " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<") {
				// SLETF = set less than
				buffer->emit("SLETF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
															  + " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == "<=") {
				// if $1 <= $3, then $3 > $1 (SGRTF = set greater than)
				buffer->emit("SGRTF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
			else if ($2.str == ">") {
				// SGRTF = set greater than
				buffer->emit("SGRTF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BREQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg==0
			}
			else if ($2.str == ">=") {
				// if $1 >= $3, then $3 < $1 (SLETF = set less than)
				buffer->emit("SLETF F" + intToString(tempReg) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
				buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString(tempReg));
				buffer->emit("BNEQZ I" + intToString($$.regNum) + " "); // falseList, jump if reg!=0
			}
		}
		buffer->emit("UJUMP "); // trueList

	}
	| LPAREN BEXP RPAREN { 
		$$.trueList = $2.trueList;
		$$.falseList = $2.falseList;
	}
;

// expression rules
EXP : EXP ADDOP EXP { 
		if ($1.type == void_t || $3.type == void_t){
			printSemanticError("Can't add void");
		}
		else if ($1.type != $3.type){
			printSemanticError("Type mismatch in addition");
		}
		$$.type = $1.type;
		if ($1.type == int_t){
			$$.regNum = currentScopeRegsNumInt++;
			if ($2.str == "+") {
				buffer->emit("ADD2I I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
			else { // $2.str == "-"
				buffer->emit("SUBTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
		}
		else if ($1.type == float_t){
			$$.regNum = currentScopeRegsNumFloat++;
			if ($2.str == "+") {
				buffer->emit("ADD2F F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
			else { // $2.str == "-"
				buffer->emit("SUBTF F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
		}
	}
	| EXP MULOP EXP {
		if ($1.type == void_t || $3.type == void_t){
			printSemanticError("Can't multiply void");
		}
		else if ($1.type != $3.type){
			printSemanticError("Type mismatch in multiplication");
		}
		$$.type = $1.type;
		if ($1.type == int_t){
			$$.regNum = currentScopeRegsNumInt++;
			if ($2.str == "*") {
				buffer->emit("MULTI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
			else { // $2.str == "/"
				buffer->emit("DIVDI I" + intToString($$.regNum) + " I" + intToString($1.regNum) 
																+ " I" + intToString($3.regNum));
			}
		}
		else if ($1.type == float_t){
			$$.regNum = currentScopeRegsNumFloat++;
			if ($2.str == "*") {
				buffer->emit("MULTF F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
			else { // $2.str == "/"
				buffer->emit("DIVDF F" + intToString($$.regNum) + " F" + intToString($1.regNum) 
																+ " F" + intToString($3.regNum));
			}
			
		}
	}
	| LPAREN EXP RPAREN { 
		$$ = $2;
	}
	| LPAREN TYPE RPAREN EXP { 
		// check if the types arent void
		if (($4.type == void_t) && ($2.type != void_t)){
			printSemanticError("Can't cast from void to non-void");
		}

		if ($2.type == $4.type){
			$$ = $4;
		}
		else if ($2.type == int_t && $4.type == float_t){
			$$.type = $2.type;
			$$.offset = $4.offset;
			// convert float to int
			$$.regNum = currentScopeRegsNumInt++;
			buffer->emit("CFTOI I" + intToString($$.regNum) + " F" + intToString($4.regNum));
			
		}
		else if ($2.type == float_t && $4.type == int_t){
			$$.type = $2.type;
			$$.offset = $4.offset;
			// convert int to float
			$$.regNum = currentScopeRegsNumFloat++;
			buffer->emit("CITOF F" + intToString($$.regNum) + " I" + intToString($4.regNum));
		}
		else { // $2.type == void_t
			$$.type = $2.type;
		}
	}
	| ID { 
		// check if in symbol table with $1
	  	if (symbolTable->find($1.str) == symbolTable->end()){
			// not found in symbol table
			printSemanticError("Variable " + $1.str + " not declared");
		}
		string name = $1.str;
		int depth = symbolTable[name].depth;
		$$.type = symbolTable[name].type[depth];
		if ($$.type == int_t){
			$$.regNum = currentScopeRegsNumInt++;
			$$.offset = symbolTable[name].offset[depth];
			buffer->emit("LOADI I" + intToString($$.regNum) + " I1 " + intToString($$.offset));
		}
		else if ($$.type == float_t){
			$$.regNum = currentScopeRegsNumFloat++;
			$$.offset = symbolTable[name].offset[depth];
			// load I1 into F1
			buffer->emit("CITOF F1 I1");
			// load float
			buffer->emit("LOADF F" + intToString($$.regNum) + " F1 " + intToString($$.offset));
		}
	}
	| NUM { 
		$$ = $1;
	}
	| CALL {
		// the result of the function call is in $1
		$$.type = $1.type;
		if ($$.type != void_t){
			$$.regNum = $1.regNum;
		}
	}
;

// number rules
NUM : INTEGERNUM { 
		$$.type = int_t;
		$$.regNum = currentScopeRegsNumInt++;
		$$.value = $1.str;
		buffer->emit("COPYI I" + intToString($$.regNum) + " " + $1.str);
	}
	| REALNUM { 
		$$.type = float_t;
		$$.regNum = currentScopeRegsNumFloat++;
		$$.value = $1.str;
		buffer->emit("COPYF F" + intToString($$.regNum) + " " + $1.str);
	}
;

// function call rules
CALL : ID LPAREN CALL_ARGS RPAREN {
		string functionName = $1.str;
		// check if the function is declared
		if (functionTable->find(functionName) == functionTable->end()){
			// not found in symbol table
			printSemanticError("Function '" + functionName + "' not declared");
		}
		// check if the number of arguments match (including optional arguments)
		int totalArgs = functionTable[functionName].paramTypes.size(); // total number of arguments including optional
		int inputedArgs = $3.argTypes.size(); // number of inputed arguments
		int maxOptionalArgs = functionTable[functionName].maxOptionalArgs;
		if ((inputedArgs < totalArgs - maxOptionalArgs) || (inputedArgs > totalArgs)){
			printSemanticError("Number of arguments in function call of '" + functionName + "' doesn't match");
		}

		// check if the types of arguments match
		for (int i = 0; i < inputedArgs; i++){
			if ($3.argTypes[i] != functionTable[functionName].paramTypes[i]){
				printSemanticError("Type mismatch in function call of '" + functionName + "'");
			}
		}
		
		// we only use types of 4 bytes (int, float), everything is alligned to 4 bytes
		// save all used registers to stack
		int offset = 0;
		// calculate num of optional arguments passed
		int numOptionalArgsPassed = inputedArgs - (totalArgs - maxOptionalArgs);
		int tempReg = currentScopeRegsNumInt++;
		buffer->emit("COPYI I" + intToString(tempReg) + " " + intToString(numOptionalArgsPassed));
		// set F2 to be the same as I2
		buffer->emit("CITOF F2 I2");
		for (int i = 0; i < currentScopeRegsNumInt; i++){
			buffer->emit("STORI I" + intToString(i) + " I2 " + intToString(offset));
			offset += 4;
		}
		/*********************************************************************************/
		// need to figure out the thing with float registers
		offset += 8; // 4 bytes for return value and 4 bytes for num of optional arguments passed

		int paramsCurrentOffset = -8;
		int paramCount = $3.paramRegs.size();
		vector<Type> paramTypes = $3.paramTypes;
		vector<int> paramRegs = $3.paramRegs;
		vector<int> paramOffsets;
		
		if (numOptionalArgsPassed > 0) {
			buffer->emit("STORI")
		}
		// calculate the size of the stack with all the arguments
		for (int i = 0; i < paramCount; i++){
			if (paramTypes[i] == int_t){
				offset += 4;
				paramsCurrentOffset -= 4;
			}
			else if (paramTypes[i] == float_t){
				offset += 4;
				paramsCurrentOffset -= 4;
			}
			paramOffsets.push_back(paramsCurrentOffset);
		}
		// set the stack pointer (I2) to the top of the stack
		buffer->emit("ADDI I2 I2 " + intToString(offset));
		currentScopeOffset += offset;
		// set I1 to the address of the first argument
		buffer->emit("COPYI I1 I2");
		buffer->emit("CITOF F1 I1")

		// store arguments to the stack
		for (int i = 0; i < paramCount; i++){
			if (paramTypes[i] == int_t){
				buffer->emit("STORI I" + intToString(paramRegs[i]) + " I1 " + intToString(paramOffsets[i]));
			}
			else if (paramTypes[i] == float_t){
				buffer->emit("STORF F" + intToString(paramRegs[i]) + " F1 " + intToString(paramOffsets[i]));
			}
		}
		// store num of optional arguments passed
		buffer->emit("STORI I" + intToString(tempReg) + " I1 -8");

		// call function
		// add the address of the function call to the calling addresses of the function
		functionTable[functionName].callingAddresses.push_back(buffer->nextquad());
		buffer->emit("JLINK ");

		// back from function call, restore registers

		// set the stack pointer (I2) to the top of the stack
		buffer->emit("COPYI I2 I1");

		// set return value to a register
		if (functionTable[functionName].returnType == int_t){
			$$.type = int_t;
			$$.regNum = currentScopeRegsNumInt;
			buffer->emit("LOADI I" + intToString($$.regNum) + " I1 -4");
		}
		else if (functionTable[functionName].returnType == float_t){
			$$.type = float_t;
			$$.regNum = currentScopeRegsNumFloat;
			buffer->emit("CITOF F1 I1");
			buffer->emit("LOADF F" + intToString($$.regNum) + " F1 -4");
		}
		else {
			$$.type = void_t;
		}
		// close the stack
		buffer->emit("SUBI I2 I2 " + intToString(offset));
		buffer->emit("CITOF F2 I2");

		// restore registers
		offset = 0;
		// LOADI for all integer registers (no need to restore return value, it's already restored)
		for (int i = 0; i < currentScopeRegsNumInt; i++){
			// skip I2
			if (i == 2){
				offset += 4;
				continue;
			}
			buffer->emit("LOADI I" + intToString(i) + " I2 " + intToString(offset));
			offset += 4;
		}

		// LOADF for all float registers (no need to restore return value, it's already restored)

		if (functionTable[functionName].returnType == int_t){
			currentScopeRegsNumInt++;
		}
		else if (functionTable[functionName].returnType == float_t){
			currentScopeRegsNumFloat++;
		}
	}
;

// function call argument rules
CALL_ARGS : CALL_ARGLIST {
		// insert arguments to CALL_ARGS
		$$.argTypes = $1.paramTypes;
		$$.argRegs = $1.paramRegs;
		// clear CALL_ARGLIST
		$1.paramTypes.clear();
		$1.paramRegs.clear();
	}
	| /* empty */ {} %empty
;

// function call argument list rules
CALL_ARGLIST : CALL_ARGLIST COMMA EXP {
		// insert arguments to CALL_ARGLIST from CALL_ARGLIST
		$$.paramTypes = $1.paramTypes;
		$$.paramRegs = $1.paramRegs;
		// insert arguments to CALL_ARGLIST from EXP
		$$.paramTypes.push_back($3.type);
		$$.paramRegs.push_back($3.regNum);
		// clear CALL_ARGLIST
		$1.paramTypes.clear();
		$1.paramRegs.clear();
	}
	| EXP {
		// arguments cant be void
		$$.paramTypes.push_back($1.type);
		$$.paramRegs.push_back($1.regNum);
	}
;

M : /* empty */ { 
		$$.quad = buffer->nextquad() 
	} %empty
;

N : /* empty */ { 	
		$$.nextList.push_back(buffer->nextquad());
		buffer->emit("UJUMP ");
	} %empty
;
%%

void yyerror(char const * message)
{
    printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
    exit(SYNTAX_ERROR);
}

void printSemanticError(string error){
	cout << "Semantic error: " << error << " in line number " << yylineno << endl;
	exit(SEMANTIC_ERROR);
}

void printOperationalError(string error){
	cout << "Operational error: " << error << endl;
	exit(OPERATIONAL_ERROR);
}