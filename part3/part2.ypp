%{
	#include "part2_helpers.h"
    #include <iostream>
	#include <stdio.h>

    using namespace std;
    
	extern char *yytext;
	extern int yylineno;
	extern int yylex();
	// ParserNode *parseTree; /* Root of parse tree. Defined in the parser. */
	
	void yyerror(char const * message);
%}
// declare union type for tokens
%union {
	char *str;
	// ParserNode *node;
}
// declare types of non-terminal symbols
//%type PROGRAM FDEFS FUNC_DEC_API FUNC_DEF_API FUNC_DEF_ARGLIST_OPT FUNC_DEC_ARGLIST_OPT DCL_OPT DCL_OPT_VAL FUNC_ARGLIST BLK DCL TYPE STLIST STMT RETURN WRITE READ ASSN LVAL CNTRL BEXP EXP NUM CALL CALL_ARGS CALL_ARGLIST
// declare tokens we get from lexer and their types and their associativity
%token <str> INT FLOAT VOID WRITE_ READ_ OPTIONAL WHILE DO IF RETURN_ COLON SEMICOLON ID INTEGERNUM REALNUM STR 

%right <str> THEN
%right <str> ELSE

%left <str> COMMA
%right <str> ASSIGN
%left <str> OR
%left <str> AND
%left <str> RELOP
%left <str> ADDOP
%left <str> MULOP
%right <str> LPAREN RPAREN NOT
%left <str> LBRACE RBRACE

%%
// define grammar rules
// root rule
PROGRAM : FDEFS { }
;

FDEFS :   FDEFS FUNC_DEF_API BLK { }
		| FDEFS FUNC_DEC_API { }
		| /* empty */ { } %empty
;

// function declaration rules
FUNC_DEC_API :   TYPE ID LPAREN RPAREN SEMICOLON { }
			   | TYPE ID LPAREN FUNC_ARGLIST RPAREN SEMICOLON { }
			   | TYPE ID LPAREN FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { }
			   | TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { }
;

FUNC_DEC_ARGLIST_OPT :   FUNC_DEC_ARGLIST_OPT COMMA DCL_OPT { }
					   | DCL_OPT { }
;

DCL_OPT : ID COLON OPTIONAL TYPE { }
		  | ID COMMA DCL_OPT{ }
;

// function definition rules
FUNC_DEF_API : TYPE ID LPAREN RPAREN {}
			   | TYPE ID LPAREN FUNC_ARGLIST RPAREN {}
			   | TYPE ID LPAREN FUNC_DEF_ARGLIST_OPT RPAREN {}
			   | TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEF_ARGLIST_OPT RPAREN {}
;

FUNC_DEF_ARGLIST_OPT : FUNC_DEF_ARGLIST_OPT COMMA DCL_OPT_VAL {}
					   | DCL_OPT_VAL{ }
;

DCL_OPT_VAL : ID ASSIGN NUM COLON OPTIONAL TYPE { }
			  | ID ASSIGN NUM COMMA DCL_OPT_VAL { }
;

// function argument list rules
FUNC_ARGLIST : FUNC_ARGLIST COMMA DCL {}
			   | DCL { }
;

// block rules
BLK : LBRACE STLIST RBRACE { }
;

// declaration rules
DCL : ID COLON TYPE { } // variable: int
	  | ID COMMA DCL { } // var1, var2, var3: int
;

// type rules
TYPE : INT { $$ = new TYPEnode("int"); }
	   | FLOAT { $$ = new TYPEnode("float");}
	   | VOID { $$ = new TYPEnode("void");}
;

// statement list rules
STLIST : STLIST STMT {}
		 | /* empty */ { } %empty
;

// statement rules
STMT : DCL SEMICOLON {}
	   | ASSN { }
	   | EXP SEMICOLON {}
	   | CNTRL { }
	   | READ { }
	   | WRITE { }
	   | RETURN { }
	   | BLK {}
;

// return, write, read, assignment rules
RETURN : RETURN_ EXP SEMICOLON { }
	   | RETURN_ SEMICOLON { }
;

WRITE : WRITE_ LPAREN EXP RPAREN SEMICOLON {// check type of EXP
											// get value from EXP
											// insert code into code vector for write
 }
		| WRITE_ LPAREN STR RPAREN SEMICOLON { // print string char by char using ascii values
												// insert code into code vector for write
		 }
;
/* example
ADD2I I3 I1 0 // I3 = I1 + 0 (calculate address of I1, done by LVAL)
READI I4 	  // read integer f
STORI I4 I3 0
*/
READ : READ_ LPAREN LVAL RPAREN SEMICOLON { // take type from LVAL
											// create new tmp register
											// read into tmp register
											// store tmp register value into memory (store) with LVAL address
											}

;
// assignment rules
/* example
ADD2I I3 I1 0 // I3 = I1 + 0 (calculate address of I1, done by LVAL)
STORI I4 I3 0
*/
ASSN : LVAL ASSIGN EXP SEMICOLON { // check types
									// get value from EXP
									// get address from LVAL
									// store value into memory (store)
 }
;
// left value rules
LVAL : ID { // check if in symbol table with $1
	  	    // add code to take value from memory (load)
			// put type in $$.type
			// create new tmp register
}
;

// control flow rules
CNTRL : IF BEXP THEN M STMT N ELSE M STMT N { vector<int> trueList = $2->getTrueList();
											vector<int> falseList = $2->getFalseList();
											delete $2;
											vector<int> nextListS1 = $5->getNextList();
											vector<int> nextListN1 = $6->getNextList();
											vector<int> nextListS2 = $9->getNextList();
											vector<int> nextListN2 = $10->getNextList();
											// insert code into code vector for if statement
											// backpatch trueList with M $4
											// backpatch falseList with M $8
											// add N.nextList to Cntrl.nextList
											vector<int> nextList = merge(nextListS1,merge(nextListS2 ,merge(nextListN1, nextListN2)));
											$$ = new CNTRLnode(nextList);}
		| IF BEXP THEN M STMT N { vector<int> trueList = $2->getTrueList();
								vector<int> falseList = $2->getFalseList();
								delete $2;
								vector<int> nextListS = $5->getNextList();
								vector<int> nextListN = $6->getNextList();
								// insert code into code vector for if statement
								// backpatch trueList with M $4
								// add S.nextList to Cntrl.nextList

								vector<int> nextList = merge(falseList, merge(nextListS, nextListN));
								$$ = new CNTRLnode(nextList);}
		| WHILE M BEXP DO M STMT { vector<int> trueList = $3->getTrueList();
							    vector<int> falseList = $3->getFalseList();
								delete $3;
							   	vector<int> nextListS = $6->getNextList();
							   	// insert code into code vector for while loop
							   	// backpatch trueList with M $5
							   	// backpatch nextListS with M $2
							   	// add jump M $2 after S
							   	$$ = new CNTRLnode(falseList);}
;

// boolean and expression rules
BEXP : BEXP OR M BEXP { vector<int> trueList1 = $1->getTrueList();
					  vector<int> falseList1 = $1->getFalseList();
					  vector<int> trueList2 = $3->getTrueList();
					  vector<int> falseList2 = $3->getFalseList();
					  delete $1;
					  delete $3;
					  // insert code into code vector for OR
					  // backpatch falseList1 with M
					  vector<int> trueList = merge(trueList1, trueList2);
					  vector<int> falseList = falseList2;
					  $$ = new BEXPnode(falseList, trueList);}
	   | BEXP AND M BEXP { 
						vector<int> trueList1 = $1->getTrueList();
						vector<int> falseList1 = $1->getFalseList();
						vector<int> trueList2 = $3->getTrueList();
						vector<int> falseList2 = $3->getFalseList();
						delete $1;
						delete $3;
						// insert code into code vector for AND
						// backpatch trueList1 with M
						vector<int> trueList = trueList2;
						vector<int> falseList = merge(falseList1, falseList2);
						$$ = new BEXPnode(falseList, trueList);
	   }
	   | NOT BEXP { vector<int> trueList = $2->getTrueList();
					 vector<int> falseList = $2->getFalseList();
					 delete $2;
					 $$ = new BEXPnode(falseList, trueList);}
	   | EXP RELOP EXP { string type1 = $1->getType();
						 string value2 = $1->getValue();
						 bool isConst1 = $1->isConst();
						 if (!isConst1){
							 Register * reg1 = $1->getRegister();	
						 }
						 string type2 = $3->getType();
						 string value2 = $3->getValue();
						 bool isConst2 = $3->isConst();
						 if (!isConst2){
							 Register * reg2 = $3->getRegister();	
						 }
						 delete $1;
						 delete $3;
						 // check if types are compatible
						 if (type1 != type2) {
							 // error massage
							 printSemanticError("Type mismatch in comparison", yylineno);
							 exit(1);
						 }
						 // insert code into code vector for comparison
						 // remember to add jumps to true and false lists
						 vector<int> trueList;
						 vector<int> falseList;

						 $$ = new BEXPnode(trueList, falseList);}
	   | LPAREN BEXP RPAREN { $$ = $2;}
;

// expression rules
EXP : EXP ADDOP EXP { string type1 = $1->getType();
					string value2 = $1->getValue();
					bool isConst1 = $1->isConst();
					if (!isConst1){
						Register * reg1 = $1->getRegister();	
					}
					string type2 = $3->getType();
					string value2 = $3->getValue();
					bool isConst2 = $3->isConst();
					if (!isConst2){
						Register * reg2 = $3->getRegister();	
					}
					delete $1;
					delete $3;
					// check if types are compatible
					if (type1 != type2) {
						// error massage
						printSemanticError("Type mismatch in multiplication", yylineno);
						exit(1);
					}
					// insert code into code vector for multiplication
					Register * reg = new Register(type1, value);
					$$ = new EXPnode(type1, false, "", reg);}
	  | EXP MULOP EXP { string type1 = $1->getType();
						string value2 = $1->getValue();
						bool isConst1 = $1->isConst();
						if (!isConst1){
							Register * reg1 = $1->getRegister();	
						}
						string type2 = $3->getType();
						string value2 = $3->getValue();
						bool isConst2 = $3->isConst();
						if (!isConst2){
							Register * reg2 = $3->getRegister();	
						}
						delete $1;
						delete $3;
						// check if types are compatible
						if (type1 != type2) {
							// error massage
							printSemanticError("Type mismatch in multiplication", yylineno);
							exit(1);
						}
						// insert code into code vector for multiplication
						Register * reg = new Register(type1, value);
						$$ = new EXPnode(type1, false, "", reg);}
	  | LPAREN EXP RPAREN { $$ = $2;}
	  | LPAREN TYPE RPAREN EXP { // insert code into code vector for type casting
	  							 string type = $2->getType();
								 delete $2;
								 string value = $4->getValue();
								 // cast value to currect type
								 Register * reg = new Register(type, value);
								 delete $4;
								 $$ = new EXPnode(type, false, value, reg);
	  }
	  | ID { // check if in symbol table with $1
	  	 	 string type = ""; // get type from symbol table
			 string value = ""; // get value from symbol table
			 Register * reg = NULL; // get register from symbol table
	  		 $$ = new EXPnode(type, false, value, reg);
	  }
	  | NUM { string type = $1->getType();
	  		  string value = $1->getValue();
			  delete $1;
			  $$ = new EXPnode(type, true, value, NULL);}
	  | CALL {}
;

// number rules
NUM : INTEGERNUM { $$ = new  NUMnode("int", $1) }
	  | REALNUM { $$ = new NUMnode("float", $1) }
;

// function call rules
CALL : ID LPAREN CALL_ARGS RPAREN {}
;

// function call argument rules
CALL_ARGS : CALL_ARGLIST {}
			| /* empty */ {} %empty
;

// function call argument list rules
CALL_ARGLIST : CALL_ARGLIST COMMA EXP {}
			   | EXP {}
;

M : /* empty */ { $$ = nextQuad(); } %empty
;

N : /* empty */ { vector<int> nextList;
				  nextList.push_back(nextQuad());
				  // insert code into code vector for jump
				  $$ = new Nnode(nextList); } %empty
;
%%

void yyerror(char const * message)
{
    printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
    exit(2);
}
