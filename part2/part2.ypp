%{
    #include "part2.hpp"
	#include "part2_helpers.h"
    #include <iostream>
	#include <stdio.h>

    using namespace std;
    
	extern char *yytext;
	extern int yylineno;
	extern int yylex();
	ParserNode *parseTree; /* Root of parse tree. Defined in the parser. */
	
	void yyerror(char const * message);
%}
// declare union type for tokens
%union {
	ParserNode *node;
}
// declare tokens we get from lexer and their types
%token <node> INT FLOAT VOID WRITE_ READ_ OPTIONAL WHILE DO IF THEN ELSE RETURN_
%token <node> LPAREN RPAREN LBRACE RBRACE COMMA COLON SEMICOLON 
%token <node> ID INTEGERNUM REALNUM STR 
%token <node> RELOP ADDOP MULOP ASSIGN AND OR NOT
// declare non-terminal symbols and their types
%type <node> PROGRAM FDEFS FUNC_DEC_API FUNC_DEF_API FUNC_DEF_ARGLIST_OPT FUNC_DEC_ARGLIST_OPT DCL_OPT DCL_OPT_VAL FUNC_ARGLIST BLK DCL TYPE STLIST STMT RETURN WRITE READ ASSN LVAL CNTRL BEXP EXP NUM CALL CALL_ARGS CALL_ARGLIST
// define associativity for relevant tokens
%left RELOP ADDOP MULOP AND OR COMMA LBRACE RBRACE
%right ASSIGN NOT LPAREN RPAREN ELSE THEN // make sure that the right associativity is correct

%%
// define grammar rules
// root rule
PROGRAM : FDEFS { parseTree = makeNode("PROGRAM", NULL, $1);}
;

FDEFS :   FDEFS FUNC_DEF_API BLK { $$ = makeNode("FDEFS", NULL, concatList($1, concatList($2, $3)));}
		| FDEFS FUNC_DEC_API { $$ = makeNode("FDEFS", NULL, concatList($1, $2));}
		| /* empty */ { $$ = makeNode("FDEFS", NULL, makeNode("EPSILON", NULL, NULL)); } %empty
;

// function declaration rules
FUNC_DEC_API :   TYPE ID LPAREN RPAREN SEMICOLON { concatList($1, $2);
												   concatList($2, $3);
												   concatList($3, $4);
												   concatList($4, $5);
												   $$ = makeNode("FUNC_DEC_API", NULL, $1);}
			   | TYPE ID LPAREN FUNC_ARGLIST RPAREN SEMICOLON { concatList($1, $2);
																concatList($2, $3);
																concatList($3, $4);
																concatList($4, $5);
																concatList($5, $6);
																$$ = makeNode("FUNC_DEC_API", NULL, $1);}
			   | TYPE ID LPAREN FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { concatList($1, $2);
																		concatList($2, $3);
																		concatList($3, $4);
																		concatList($4, $5);
																		concatList($5, $6);
																		$$ = makeNode("FUNC_DEC_API", NULL, $1);}
			   | TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEC_ARGLIST_OPT RPAREN SEMICOLON { concatList($1, $2);
																						   concatList($2, $3);
																						   concatList($3, $4);
																						   concatList($4, $5);
																						   concatList($5, $6);
																						   concatList($6, $7);
																						   concatList($7, $8);
																						   $$ = makeNode("FUNC_DEC_API", NULL, $1);}
;

FUNC_DEC_ARGLIST_OPT :   FUNC_DEC_ARGLIST_OPT COMMA DCL_OPT { concatList($1, $2);
															  concatList($2, $3);
															  $$ = makeNode("FUNC_DEC_ARGLIST_OPT", NULL, $1);}
					   | DCL_OPT { $$ = makeNode("FUNC_DEC_ARGLIST_OPT", NULL, $1);}
;

DCL_OPT : ID COLON OPTIONAL TYPE {concatList($1, $2);
								  concatList($2, $3);
								  concatList($3, $4);
								  $$ = makeNode("DCL_OPT", NULL, $1);}
		  | ID COMMA DCL_OPT{concatList($1, $2);
							 concatList($2, $3);
							 $$ = makeNode("DCL_OPT", NULL, $1);}
;

// function definition rules
FUNC_DEF_API : TYPE ID LPAREN RPAREN {concatList($1, $2);
									  concatList($2, $3);
									  concatList($3, $4);
									  $$ = makeNode("FUNC_DEF_API", NULL, $1);}
			   | TYPE ID LPAREN FUNC_ARGLIST RPAREN {concatList($1, $2);
													 concatList($2, $3);
													 concatList($3, $4);
													 concatList($4, $5);
													 $$ = makeNode("FUNC_DEF_API", NULL, $1);}
			   | TYPE ID LPAREN FUNC_DEF_ARGLIST_OPT RPAREN {concatList($1, $2);
															concatList($2, $3);
															concatList($3, $4);
															concatList($4, $5);
															$$ = makeNode("FUNC_DEF_API", NULL, $1);}
			   | TYPE ID LPAREN FUNC_ARGLIST COMMA FUNC_DEF_ARGLIST_OPT RPAREN {concatList($1, $2);
																				concatList($2, $3);
																				concatList($3, $4);
																				concatList($4, $5);
																				concatList($5, $6);
																				concatList($6, $7);
																				$$ = makeNode("FUNC_DEF_API", NULL, $1);}
;

FUNC_DEF_ARGLIST_OPT : FUNC_DEF_ARGLIST_OPT COMMA DCL_OPT_VAL {concatList($1, $2);
															   concatList($2, $3);
															   $$ = makeNode("FUNC_DEF_ARGLIST_OPT", NULL, $1);}
					   | DCL_OPT_VAL{ $$ = makeNode("FUNC_DEF_ARGLIST_OPT", NULL, $1);}
;

DCL_OPT_VAL : ID ASSIGN NUM COLON OPTIONAL TYPE {concatList($1, $2);
												concatList($2, $3);
												concatList($3, $4);
												concatList($4, $5);
												concatList($5, $6);
												$$ = makeNode("DCL_OPT_VAL", NULL, $1);}
			  | ID ASSIGN NUM COMMA DCL_OPT_VAL {concatList($1, $2);
												 concatList($2, $3);
												 concatList($3, $4);
												 concatList($4, $5);
												 $$ = makeNode("DCL_OPT_VAL", NULL, $1);}
;

// function argument list rules
FUNC_ARGLIST : FUNC_ARGLIST COMMA DCL {concatList($1, $2);
									   concatList($2, $3);
									   $$ = makeNode("FUNC_ARGLIST", NULL, $1);}
			   | DCL { $$ = makeNode("FUNC_ARGLIST", NULL, $1);}
;

// block rules
BLK : LBRACE STLIST RBRACE {concatList($1, $2);
							concatList($2, $3);
							$$ = makeNode("BLK", NULL, $1);}
;

DCL : ID COLON TYPE {concatList($1, $2);
					 concatList($2, $3);
					 $$ = makeNode("DCL", NULL, $1);}
	  | ID COMMA DCL {concatList($1, $2);
					  concatList($2, $3);
					  $$ = makeNode("DCL", NULL, $1);}
;

// type rules
TYPE : INT { $$ = makeNode("TYPE", NULL, $1);}
	   | FLOAT { $$ = makeNode("TYPE", NULL, $1);}
	   | VOID{ $$ = makeNode("TYPE", NULL, $1);}
;

// statement list rules
STLIST : STLIST STMT {concatList($1, $2);
					  $$ = makeNode("STLIST", NULL, $1);}
		 | /* empty */ { $$ = makeNode("STLIST", NULL, makeNode("EPSILON", NULL, NULL));} %empty
;

// statement rules
STMT : DCL SEMICOLON {concatList($1, $2);
					  $$ = makeNode("STMT", NULL, $1);}
	   | ASSN { $$ = makeNode("STMT", NULL, $1);}
	   | EXP SEMICOLON {concatList($1, $2);
						$$ = makeNode("STMT", NULL, $1);}
	   | CNTRL { $$ = makeNode("STMT", NULL, $1);}
	   | READ { $$ = makeNode("STMT", NULL, $1);}
	   | WRITE { $$ = makeNode("STMT", NULL, $1);}
	   | RETURN { $$ = makeNode("STMT", NULL, $1);}
	   | BLK {$$ = makeNode("STMT", NULL, $1);}
;

// return, write, read, assignment rules
RETURN : RETURN_ EXP SEMICOLON {concatList($1, $2);
								concatList($2, $3);
								$$ = makeNode("RETURN", NULL, $1);}
	   | RETURN_ SEMICOLON { $$ = makeNode("RETURN", NULL, $1);}
;

WRITE : WRITE_ LPAREN EXP RPAREN SEMICOLON { concatList($1, $2);
											concatList($2, $3);
											concatList($3, $4);
											concatList($4, $5);
											$$ = makeNode("WRITE", NULL, $1);}
		| WRITE_ LPAREN STR RPAREN SEMICOLON { concatList($1, $2);
											  concatList($2, $3);
											  concatList($3, $4);
											  concatList($4, $5);
											  $$ = makeNode("WRITE", NULL, $1);}
;

READ : READ_ LPAREN LVAL RPAREN SEMICOLON { concatList($1, $2);
										   concatList($2, $3);
										   concatList($3, $4);
										   concatList($4, $5);
										   $$ = makeNode("READ", NULL, $1);};
ASSN : LVAL ASSIGN EXP SEMICOLON { concatList($1, $2);
								   concatList($2, $3);
								   concatList($3, $4);
								   $$ = makeNode("ASSN", NULL, $1);}
;

LVAL : ID { $$ = makeNode("LVAL", NULL, $1);}
;

// control flow rules
CNTRL : IF BEXP THEN STMT ELSE STMT { concatList($1, $2);
									  concatList($2, $3);
									  concatList($3, $4);
									  concatList($4, $5);
									  concatList($5, $6);
									  $$ = makeNode("CNTRL", NULL, $1);}
		| IF BEXP THEN STMT { concatList($1, $2);
							  concatList($2, $3);
							  concatList($3, $4);
							  $$ = makeNode("CNTRL", NULL, $1);}
		| WHILE BEXP DO STMT { concatList($1, $2);
							   concatList($2, $3);
							   concatList($3, $4);
							   $$ = makeNode("CNTRL", NULL, $1);}
;

// boolean and expression rules
BEXP : BEXP OR BEXP { concatList($1, $2);
					  concatList($2, $3);
					  $$ = makeNode("BEXP", NULL, $1);}
	   | BEXP AND BEXP { concatList($1, $2);
						concatList($2, $3);
						$$ = makeNode("BEXP", NULL, $1);}
	   | NOT BEXP { concatList($1, $2);
					$$ = makeNode("BEXP", NULL, $1);}
	   | EXP RELOP EXP { concatList($1, $2);
						 concatList($2, $3);
						 $$ = makeNode("BEXP", NULL, $1);}
	   | LPAREN BEXP RPAREN { concatList($1, $2);
							  concatList($2, $3);
							  $$ = makeNode("BEXP", NULL, $1);}
;

// expression rules
EXP : EXP ADDOP EXP { concatList($1, $2);
					 concatList($2, $3);
					 $$ = makeNode("EXP", NULL, $1);}
	  | EXP MULOP EXP { concatList($1, $2);
						concatList($2, $3);
						$$ = makeNode("EXP", NULL, $1);}
	  | LPAREN EXP RPAREN { concatList($1, $2);
							concatList($2, $3);
							$$ = makeNode("EXP", NULL, $1);}
	  | LPAREN TYPE RPAREN EXP { concatList($1, $2);
								  concatList($2, $3);
								  concatList($3, $4);
								  $$ = makeNode("EXP", NULL, $1);}
	  | ID { $$ = makeNode("EXP", NULL, $1);}
	  | NUM { $$ = makeNode("EXP", NULL, $1);}
	  | CALL { $$ = makeNode("EXP", NULL, $1);}
;

// number rules
NUM : INTEGERNUM { $$ = makeNode("NUM", NULL, $1); }
	  | REALNUM { $$ = makeNode("NUM", NULL, $1); }
;

// function call rules
CALL : ID LPAREN CALL_ARGS RPAREN { concatList($1, $2);
								   concatList($2, $3);
								   concatList($3, $4);
								   $$ = makeNode("CALL", NULL, $1);}
;

// function call argument rules
CALL_ARGS : CALL_ARGLIST { $$ = makeNode("CALL_ARGS", NULL, $1);}
			| /* empty */ { $$ = makeNode("CALL_ARGS", NULL, makeNode("EPSILON", NULL, NULL));} %empty
;

// function call argument list rules
CALL_ARGLIST : CALL_ARGLIST COMMA EXP { concatList($1, $2);
										concatList($2, $3);
										$$ = makeNode("CALL_ARGLIST", NULL, $1);}
			   | EXP { $$ = makeNode("CALL_ARGLIST", NULL, $1);}
;

%%

int main(void)
{
    int rc;
#if YYDEBUG
    yydebug=1;
#endif
    rc = yyparse();
    if (rc == 0) { // Parsed successfully
        dumpParseTree();
    }
    return rc;
}


void yyerror(char const * message)
{
    printf("Syntax error: '%s' in line number %d\n", yytext, yylineno);
    exit(2);
}
